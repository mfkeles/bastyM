classdef PositionExtraction < handle_light
    %POSITIONEXTRACTION processes features generated by SpatioTemporal
    %class and calculates the position of a fly.

    properties
        bin;
        dormant_snap_feat;
        orientation;
        mask;
        rest_bouts;
        labeledRegions;
        bout_orientation;
        bout_body_parts;
        fps;
        position_cfg;
        tSnap;
    end

    methods
        function obj = PositionExtraction(position_cfg,bin,tSnap,fps)
            %POSITIONEXTRACTiON subclass object constructor

            obj.position_cfg = position_cfg;
            obj.bin = bin;
            obj.dormant_snap_feat = position_cfg.dormant_snap_feat{:};
            obj.tSnap = tSnap;
            obj.fps = fps;
            obj.bout_body_parts = position_cfg.bout_body_parts;
        end

        function outputArg = method1(obj,inputArg)
            %METHOD1 Summary of this method goes heret
            %   Detailed explanation goes here
            outputArg = obj.Property1 + inputArg;
        end

        function calculate_dormant_position(obj)
            %calculate_dormant_position determines the position of a given body part
            %during quiescence bouts.

            %calculate velocity
            meanVel = movmean(abs(diff(obj.tSnap.(obj.dormant_snap_feat))),obj.fps*obj.bin);

            %use GMM to determine when the animal is active/quiescent
            GMModel = fitgmdist(meanVel,2);

            %lower mean would indicate vel close to zero
            [~,idx] = min(GMModel.mu);

            %cluster the data
            clusters = cluster(GMModel,meanVel);

            %remove movements that are smaller 1/6th of a seconds
            amask = bwareafilt((clusters~=idx),[1,5]);
            clusters(amask) = idx;

            %filter out bouts less than 1 second
            obj.mask = bwareafilt((clusters==idx),[30,inf]);

            [obj.labeledRegions, ~] = bwlabel(obj.mask);

            regionIdx = unique(obj.labeledRegions,'sorted');
            regionIdx(regionIdx==0) = [];
            res_arr = arrayfun(@(x) sum(obj.labeledRegions==x),regionIdx);

            obj.rest_bouts = res_arr;
        end

        function [med_data,  qc_data] = calculate_median_bout(obj,body_part_name)
            %calculate_median_bout determines the median position of the
            %fly during a quiescent bout for a given body_part

            body_part_x = ['pose_',body_part_name, '_x'];
            body_part_y = ['pose_',body_part_name, '_y'];

            x_bouts = arrayfun(@(x) obj.tSnap.(body_part_x)(obj.labeledRegions==x),1:max(obj.labeledRegions),'UniformOutput',false);
            y_bouts = arrayfun(@(x) obj.tSnap.(body_part_y)(obj.labeledRegions==x),1:max(obj.labeledRegions),'UniformOutput',false);

            %this is for quality control, checks the std of the x,y
            %position. 10 - 20 pixels is acceptable.
            qc_data = [cellfun(@(x) std(x),x_bouts);cellfun(@(x) std(x),y_bouts)];

            x_med = cellfun(@(x) median(x),x_bouts);
            y_med = cellfun(@(x) median(x),y_bouts);

            med_data = array2table([x_med',y_med',obj.rest_bouts],'VariableNames',{strcat(body_part_name,'_x'),strcat(body_part_name,'_y'),'rest_dur'});

            %get the zt for the quiescent bout
            bout_time = arrayfun(@(x) round(median(find(obj.labeledRegions==x))),1:max(obj.labeledRegions));

            med_data.bout_time = bout_time';
            med_data.x_bouts = x_bouts';
            med_data.y_bouts = y_bouts';
        end

        function [dist_data] = extract_bout_distance_feat(obj,distance_feat)
            %extract_bout_distance_feat extract the desired distance_feat
            %for bouts determined by dormant_snap_feat

            dist_feat = ['distance_',distance_feat];

            d_bouts = arrayfun(@(x) obj.tSnap.(dist_feat)(obj.labeledRegions==x),1:max(obj.labeledRegions),'UniformOutput',false);

            dist_data = array2table(d_bouts,'VariableNames',dist_feat);

        end



        function get_orientation(obj)
            [partone, ~] = calculate_median_bout(obj,obj.position_cfg.bout_body_parts{1});
            [parttwo, ~] = calculate_median_bout(obj,obj.position_cfg.bout_body_parts{2});

            distance_values(:,i) = cellfun(@(x) norm(x),num2cell(partone{:,1:2} - parttwo{:,3:4},2));

        end
    end

    methods (Static)

        function plotPositionVaryDur(med_data,color,fontsize,fps)
            x_col = find(cellfun(@(x) contains(x,'_x'),med_data.Properties.VariableNames));
            y_col = find(cellfun(@(x) contains(x,'_y'),med_data.Properties.VariableNames));

            col = Plotter.tricolors();

            boutFilter = zeros(numel(med_data.rest_dur),1);
            boutFilter(med_data.rest_dur<30*60) = 1;
            boutFilter(med_data.rest_dur>=30*60) = 2;
            boutFilter(med_data.rest_dur>=30*60*5) = 3;

             titles{1} = '\color{black}< 1 min';
             titles{2} = '\color{black}1 min < bout < 5 min';
             titles{3} = '\color{black}> 5 min';

            clf
            for i=1:3
                h=subplot(1,3,i);
                Plotter.modSubPlot(h,fontsize,color)

                scatter(med_data{boutFilter==i,x_col},med_data{boutFilter==i,y_col},20,col(i,:),'filled','MarkerFaceAlpha',0.7)
                axis equal
                box on
                grid on
                [t,~] = title(titles{i});
                t.FontSize = 8;
                set(gca,'ydir','reverse')
                set(gca,'XTick',0:200:1100);
                set(gca,'YTick',0:200:800);
                Plotter.removeTickLabels(gca)
                ylim([0 800])
                xlim([0 1100])
            end

        end


    end
end

